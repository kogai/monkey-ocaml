(x: bool) -> x;
((x: bool) -> x) true;
(x: bool -> bool) -> if x true then x else x;
(x: bool) -> if x then true else false;
(x: bool) -> (y: bool) -> if x then x else y;

(x: bool -> bool) -> if x then true else false;
(x: bool -> bool) -> if x true then x else false;
((x: bool) -> x) ((x: bool) -> x);

((x: nat) -> x) 100;
((f: nat -> bool) -> (x: nat) -> f x) ((x: nat) -> true) 99;
((f: nat -> bool) -> (x: nat) -> f x) ((x: nat) -> true) true;

((f: nat -> unit) -> f) ((x: nat) -> ());
((f: nat -> unit) -> f) ((x: nat) -> x);

(*
コメント

文字列のサポートはリストの実装後
文字型のリストとして表現したいので
*)

(x: (nat * bool)) -> x;
((x: (nat * bool)) -> x) (100, true);
((x: (nat * bool)) -> x) (true, 100);
((x: (nat * bool)) -> x) (true, 100, ());

def tpl = (100, true);
((x:nat) -> x) tpl.1;
((x:nat) -> x) tpl.2; (* ExpectError *)
tpl.3; (* ExpectError *)

((x:nat) -> x) (100, true).1;
((x:nat) -> x) (100, true).2; (* ExpectError *)
((x:nat) -> x) (100, true, ()).3; (* ExpectError *)

(x: {a:nat * b:bool}) -> x;
((x: {a:nat * b:bool}) -> x) {a:100, b:true};
((x: {a:nat * b:bool}) -> x) {a:true, b:100};

(x: nat -> bool) ->
  let y = x 100 in
  y;
(x: nat -> bool) ->
  let y = x true in
  y;

def id = (x: nat) -> x;
def curried = (x:nat -> nat) -> (y:nat) -> x y;
id true;
curried id 100;
curried id true;
curried id {a: 100};

def x = {a: 100, b: true};
id x.a; (* OK *)
id x.b; (* ExpectError *)
id x.c; (* ExpectError *)

({a:100}).a;
({a:100}).b; (* ExpectError *)
(((x: {a:nat}) -> x) {a:100}).a;
(((x: {a:nat}) -> x) {a:100}).c; (* ExpectError *)

(x: (nat + bool)) -> case x of
| nat -> x
| bool -> 0
;

(x: (nat + bool)) -> case x of
| nat -> x
| bool -> x
;

(x: (nat + bool)) -> case x of
| nat -> x
| bool -> 0
| {a:nat} -> x
;

(x: (nat + bool + {a:nat})) -> case x of
| nat -> x
| bool -> 0
| {a:nat} -> x.a
;

(x: (nat + bool + {a:nat})) -> case {a:100} of
| {a:nat} -> x.a
;
